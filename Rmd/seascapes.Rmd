---
title: "Seascapes"
author: "Anna Finch"
date: "8/15/2022"
output: html_document
---
# Load Libraries
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
librarian::shelf(
    librarian, ggplot2, tibble, tidyr, readr, purrr, dplyr, stringr,
    forcats, lubridate, glue, fs, magrittr, here,
    # broom # optional
    
    # additional
    raster, sp, rgdal, maptools, rgeos, vegan, ggord, 
    gavinsimpson/ggvegan
)

library("conflicted")

conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")

# ---- set path variables
seasc_path <- here("data", "raw", "seascape")

# ---- source extract function
source(here("scripts", "seascapes_extract.R"))
```

# Load CHEMTAX and CTD data
env_cmtx created in Rmd/02_ctd_download.Rmd
```{r load-chm-ctd}
# cmtx_avgs <- read.csv(paste0(path_out, "chemtax_with_metadata.csv"))

# ---- CHEMTAX with CTD
env_cmtx <- 
    (here("data", "processed") %>%
    dir_ls(regexp = "cmtx_env_data")  %>%
    sort(decreasing = TRUE))[1] %>%
    read_csv(show_col_types  = FALSE) %>% 
    mutate(
        season = fct_relevel(season, "Winter", "Spring", "Summer", "Autumn"),
        yr_mth = format(date_time_utc, "%Y.%m")
        ) %>%
    relocate(yr_mth, .after = 2) %>%
    rename("lon" = lon.x, "lat" = lat.x)
```

# Download Seascape Data using `seascapeR`
Information on the seascapes classes: 
    https://shiny.marinebon.app/seascapes/classes.html


## Info for versioning of `raster` and `seascapeR`
NOTE: as of March 30, 2023
      - you will need to use the development version of `raster` because of some
        internal code issues with that package that hasn't been released to CRAN
      
      - you will need to update the version of `seascapeR` to "0.4.1" because a 
        function call to `rerddap::griddap` has been updated 
      

If `raster` version is not "3.6-21"     
You will need to restart R and run: pacman::p_install_gh("rspatial/raster") 

If `seasscapeR` version is not "0.4.1"     
You will need to restart R and run: pacman::p_install_gh("marinebon/seascapeR") 

## Download Seascape Raster
```{r scp-dwnld}
# ---- set location and temporal scale for each image
arg_ls <- 
    list(
        map_loc = "fknms", # FL Keys
        dataset = "global_monthly"  # or global_8day
        )

# ---- download if needed, will return files list as tibble
seascapes_match <- 
    dwnld_seascp(
        map_loc    = arg_ls$map_loc,
        path       = seasc_path, 
        ss_dataset = arg_ls$dataset,   
        ss_var     = "CLASS",         
        date_beg   = floor_date(min(env_cmtx$date_time_utc), 
                                unit = "year"),
        date_end   = ceiling_date(max(env_cmtx$date_time_utc),
                                  unit = "year"),
        del_cache  = FALSE,
        verb       = TRUE
        )  %>%
    mutate(yr_mth = str_extract(files, "[0-9]{4}\\.[0-9]{2}")) %>%
    
    # ---- Filter seascape files to the months of the data
    filter(yr_mth %in% unique(env_cmtx$yr_mth))

seascapes_match

rm(arg_ls)
# ---- unzip seascapes file
# get "fknms_global_monthly.zip" from https://shiny.marinebon.app/seascapes/. 
# select "Florida Keys" in the region pull-down tab and click "all grids (.zip)"
# to download Sanctuary files. 
# here(seasc_path, "fknms_global_monthly.zip") %>%
#     unzip(., exdir = seasc_path)
```


# Extract Seascape Class
This is based on the highest proportion for each seascape with the closer the 
center of the seascape is, the more weight given to it.

The radius around each point is 12 km as a 6 x 6 grid (4km x 4km per cell)
Steps:
1. Calculate distance for each stations to all seascape cells
2. Filter for distances bewlow 12 km
3. Caclulate inverse disance weighted per seascape class for that station
    - (1 / dist)/# of cells in seascape
    - sum all IDW per class
    - sum all IDWs 
4. Select the seascape with the highest proportion as the represenative  
5. Join seascape classes with original CTD/CHEMTAX data
```{r sc-extract}
cmtx_sea <-
    env_cmtx %>%
    nest(.by = yr_mth) %>%
    left_join(seascapes_match, 
              by = "yr_mth") %>%
    mutate(
        sc = map2(
            .x = files,
            .y = data,
            ~ extract_seascapes(.x, .y, verb = FALSE),
            .progress = TRUE)) %>%
    unnest(sc) %>%
    select(-data) %>% 
    drop_na(seascape, temp, par:sal) 

# ---- remove? ----
# making empty data frame to be filled with seascapes values
# seascapes_df <-
#     as_tibble(matrix(ncol = 4, nrow = 1),
#               .name_repair = ~ c('lon', 'lat', 'seascape', "yr_mth"))



# going through each seascapes file and extracting seascapes for each station
# and adding them to a dataframe
# for (i in 1:length(file.sea)) {
# for (i in seq(file.sea)) {
#  filename <- file.sea[i]
# for (idx in seascapes_match$yr_mth[[1]]) {
#    
#     # # extract month and year in format "YYYY.MM"
#     # yr_mth <-
#     #     gsub(pattern     = paste0(seasc_path, "grd_CLASS_"), 
#     #          replacement = "", 
#     #          x           = filename) %>% 
#     #     
#     #     gsub(pattern     = ".15.tif", 
#     #          replacement = "")
#     # make temporary dataframe with seascapes, coordinates, 
#     # and year + month for cruise
#     seascapes_temp <-
#         filter(seascapes_match, yr_mth == idx)  %>%
#         pull(1) %>%
#         extract_seascapes(.,  filter(env_cmtx, yr_mth == idx)) 
#     # 
#     # # combine the dataframes with seascapes for each cruise
#     # seascapes_df <- rbind(seascapes_df, seascapes_temp)
# }
#
# # join the chemtax and seascapes data
# cmtx_sea <-
#     env_cmtx %>% 
#     left_join(seascapes_df) %>% 
#     drop_na(seascape)
```

# CAP with Bray-Curtis?
```{r sc-cap}
seascspec <-
    cmtx_sea %>% 
    select(chloro:pras)

seasc_cap <- capscale(seascspec ~ seascape, 
                      cmtx_sea, 
                      dist = "bray")

plot(seasc_cap)

autoplot(seasc_cap,
         legend.position = 'none') 
```

# CCA
```{r sc-cca, fig.width=15, fig.height=10}
sea_cca <- cca(seascspec ~ temp + sal + par, 
               data      = cmtx_sea, 
               na.action = na.omit)

new_lab <- list(temp = "Temp", 
                sal  = "Sal", 
                par  = "PAR")

plt_ord <- 
    ggord(
        sea_cca,
        size      = 4,
        grp_in    = as.character(cmtx_sea$seascape),
        ellipse   = FALSE,
        ptslab    = TRUE,
        addsize   = 6,
        ylim      = c(-6.25, 6.25),
        xlim      = c(-4, 5),
        repel     = TRUE,
        txt       = 6,
        vec_lab   = new_lab,
        grp_title = "Seascape Class"
        ) +
    theme_classic() +
    theme(text = element_text(family = "serif", size = 20),
          legend.position = c(0.15, 0.9))

plt_ord

if (FALSE) { 
    cowplot::save_plot(
        filename = 
            here("data", "plots",
                 glue("seascape_cca",
                      format(Sys.time(), '_%Y%m%d_%H%M%S'),
                      "jpeg")
                 ),
        plot        = plt_ord,
        base_height = 10,
        base_width  = 8,
        dpi         = 600, 
        units       = "in", 
        device      = "png")
}

```

# Seasonal CCA
```{r sc-season-cca, fig.width=15, fig.height=10}
seasons <- c("Winter", "Spring", "Summer", "Autumn")

for (szn in seasons) {
     
     # filter for season
     temp_sea_df <-  
        filter(cmtx_sea, str_detect(season, szn))
     
     # filtered df and select PFTs
     temp_sea_mat <- 
        select(temp_sea_df, chloro:pras)
    
     # run CCA
     temp_cca <-
        cca(temp_sea_mat ~ temp + sal + par,
            data      = temp_sea_df,
            na.action = na.omit)
    
    cca_szn <- 
        ggord(
        temp_cca,
        size      = 4,
        grp_in    = as.character(temp_sea_df$seascape),
        ellipse   = FALSE,
        ptslab    = TRUE,
        addsize   = 6,
        ylim      = c(-6.25, 6.25),
        xlim      = c(-4, 5),
        repel     = TRUE,
        txt       = 6,
        vec_lab   = new_lab,
        grp_title = "Seascape Class"
        ) +
        theme_classic() +
        theme(text = element_text(family = "serif", 
                                  size   = 20),
              legend.position = c(0.15, 0.9))
    
    print(cca_szn)
    
    if (FALSE) {
        cowplot::save_plot(
            filename = 
                here("data", "plots",
                     glue("seascape_cca_{str_to_lower(szn)}",
                          format(Sys.time(), '_%Y%m%d_%H%M%S'),
                          ".jpeg")
                          ),
            plot        = cca_szn,
            base_height = 10,
            base_width  = 8,
            dpi         = 600, 
            units       = "in", 
            device      = "png")
        
    }
}

```

# Examine which Seascape and PFT Correlate
information on the seascapes classes: https://shiny.marinebon.app/seascapes/classes.html

## Calculate Fractions of PFT to Total Chlor-a
```{r}
# sum each seascape class
# sc_cnt <- 
    cmtx_sea %>% 
    summarize(count = n(), .by = seascape)

# sum each season and seascape class
# sc_szn_cnt <-
    cmtx_sea %>% 
    summarize(count = n(), .by = c(seascape, season))

# calc fraction of PFT for each samples
sea_fract <-
    cmtx_sea %>%
    mutate(
        # combine certain PFTs
        diat  = diat1  + diat2,
        cyano = cyano2 + cyano4,
        hapt  = hapt6  + hapt8,
        total = chloro + crypto + diat + dino + hapt + pras + cyano,
        
        # calc fraction of PFT
        across(
            .cols  = c(chloro, crypto, cyano, diat, dino, hapt, pras),
            .fns   = (\(x) x / total),
            .names = "frac_{.col}"
            )
        ) %>%
    
    select(hplc_gsfc_id:season, seascape, frac_chloro:frac_pras) %T>% 
    View(title = "Fractions") 

```
## nMDS
```{r nmds}
set.seed(1355453)
nmds <- metaMDS(seascspec, distance = "bray")
# Call:
# metaMDS(comm = as.matrix(seascspec), distance = "bray")
# 
# global Multidimensional Scaling using monoMDS
# 
# Data:     as.matrix(seascspec)
# Distance: bray
# 
# Dimensions: 2
# Stress:     0.1336686
# Stress type 1, weak ties
# Best solution was repeated 16 times in 20 tries
# The best solution was from try 4 (random start)
# Scaling: centring, PC rotation, halfchange scaling
# Species: expanded scores based on ‘as.matrix(seascspec)


# extract NMDS scores (x and y coordinates) for sites from newer versions of vegan package
data_scores <-
    as_tibble(scores(nmds)$sites) %>%
    
    # add columns to data frame
    bind_cols(select(cmtx_sea, sample, season, seascape)) %T>% 
    print(slice_head(n = 10))
```

## nMDS Plot
```{r nmds-plt, fig.width=25, fig.height=15}
tol_muted <- c('#88CCEE', '#44AA99', '#117733', '#332288', '#DDCC77', '#999933',
               '#CC6677', '#882255', '#AA4499', '#BBBBBB', '#FFAABB')

xx <-
    ggplot(data_scores, aes(x = NMDS1, y = NMDS2)) +
    geom_point(size = 4, aes(shape = season, color = factor(seascape)),
               alpha = 0.75) +
    # geom_point(size = 4, aes(color = factor(seascape)))+
    #
    labs(
        x     = names(data_scores)[1],
        color = "Seascape Class",
        y     = names(data_scores)[2],
        shape = "Season"
        )  +
    # scale_shape_manual(values = c(0, 1, 2, 5, 3)) +
    # labs(x = "NMDS1", colour = "Seascape Class", y = "NMDS2") +
    scale_colour_manual(values = tol_muted) +
    ggthemes::theme_tufte() +
    theme(
        axis.text.y = element_text(
            colour = "black",
            size   = 12,
            face   = "bold"
        ),
        axis.text.x = element_text(
            colour = "black",
            face   = "bold",
            size   = 12
        ),
        legend.text = element_text(
            size   = 12,
            face   = "bold",
            colour = "black"
        ),
        # legend.position = c(0.87, 0.3),
        legend.position = "right",
        axis.title.y = element_text(face = "bold", size = 14),
        axis.title.x = element_text(
            face   = "bold",
            size   = 14,
            colour = "black"
        ),
        legend.title = element_text(
            size   = 14,
            colour = "black",
            face   = "bold"
        ),
        panel.background = element_blank(),
        panel.border     = element_rect(
            colour = "black",
            fill   = NA,
            linewidth = 1.2
        ),
        legend.key = element_blank()
    ) 
 
xx

if (FALSE) {
    cowplot::save_plot(
        filename    = here("data", "plots",
                           glue("seascape_nmds",
                            format(Sys.time(), '_%Y%m%d_%H%M%S'),
                            ".jpg")),
        plot        = xx,
        base_height = 8,
        base_width  = 14,
        dpi         = 600,
        units       = "in",
        device      = "png"
        )
}
```
## ANONISM
```{r anonism}
ano1 <-
    anosim(as.matrix(seascspec), 
           factor(cmtx_sea$seascape), 
           distance = "bray", 
           permutations = 100)

ano2 <- 
    anosim(as.matrix(seascspec),
           factor(cmtx_sea$season), 
           distance = "bray", 
           permutations = 100)
ano1
ano2

```
Seascape
ANOSIM statistic R: 0.2343 
      Significance: 0.009901 

Permutation: free
Number of permutations: 100

Season
ANOSIM statistic R: 0.1379 
      Significance: 0.009901 

Permutation: free
Number of permutations: 100

```{r}
# which functional types dominated each seascape class by season?
# sea_type_avgs <-
    cmtx_sea %>% 
    summarise(
        .by = c(season, seascape),
        across(
            .cols = chloro:pras,
            (\(x) mean(x, na.rm = TRUE))
            )) %>% 
    mutate(
        .keep = "none",
        season,
        seascape,
        total = chloro + crypto + diat1 + diat2 + dino + hapt6 + hapt8 +
            pras + cyano2 + cyano4,
        # calc fraction of PFT
        across(
            .cols  = 3:last_col(1),
            .fns   = (\(x) x / total),
            .names = "frac_{.col}"
            )
    ) #%>%
    # not sure what this part is for, `sum_avg` would be a sum of fraction  
    # which is 1
    # select(-total) %>%
    # rowwise() %>%
    # mutate(avg_sum = sum(c_across(starts_with("frac")))) %>%
    # ungroup() 

# sea_type_avgs2 <-
    cmtx_sea %>% 
    summarise(
        .by = c(season, seascape),
        across(
            .cols = chloro:pras,
            (\(x) mean(x, na.rm = TRUE))
            )) %>%
    mutate(
        .keep = "none",
        season, 
        seascape,
        diat = diat1 + diat2,
        cyano = cyano2 + cyano4,
        hapt = hapt6 + hapt8,
        total = chloro + crypto + diat + dino + hapt + pras + cyano,
        across(
            .cols  = 3:last_col(1),
            .fns   = (\(x) x / total),
            .names = "frac_{.col}"
         )
       )
    

```






